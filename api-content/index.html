{"posts":[{"title":"Mac 配置 Apache 与 PHP 环境","content":"启动 Apache macOS 自带有 Apache，只需要在终端启动即可。 sudo apachectl start sudo apachectl stop sudo apachectl restart sudo apachectl -v 自带的 Apache 默认根目录位于 /Library/WebServer/Documents 配置 PHP macOS 还是有自带 PHP，但是系统版本不同，自带的 PHP 版本也不一样，我的 10.13.6 自带的是 PHP7。 前往 Apache 目录下 /etc/apache2 修改 httpd.conf，将下方配置取消注释即可。（PHP5 同理） #LoadModule php7_module libexec/apache2/libphp7.so 修改 Apache 默认根目录 默认的根目录修改需要管理员权限，查找起来也麻烦。将其修改至自定义目录。这一步网上教程极多，但是我在配置的过程中却踩了个坑，下面先阐述我的配置步骤。 首先还是修改 httpd.conf ，找到默认路径修改掉。 #DocumentRoot &quot;/Library/WebServer/Documents&quot; #&lt;Directory &quot;/Library/WebServer/Documents&quot;&gt; DocumentRoot &quot;/CustomPath&quot; &lt;Directory &quot;/CustomPath&quot;&gt; 这样配置完成后访问会提示 403 错误。 Forbidden You don't have permission to access / on this server. 百度查找了半天，千篇一律是要修改 Directory 中的配置为下方所诉。但是无效果。 Options FollowSymLinks AllowOverride None Order deny, allow Allow from All 许久终于在某篇博客（感恩，但是忘记留地址了抱歉）找到症结所在，需要将配置文件中的 User 修改为系统用户即可。 #User _www User username Group _www 最终配置完成只进行了两步操作：1、修改目录；2、修改 User。 ","link":"https://ikerwin.com/post/mac-pei-zhi-apache-yu-php-huan-jing/"},{"title":"在 Java 使用 LDAP 进行用户操作","content":"前一段时间单位的统一身份认证系统进行了升级，新版本不支持接口认证，就只能摸索一下和 LDAP 的对接。也鼓捣了一段时间，在这记录一下。 简介 LDAP 是轻量目录访问协议(Lightweight Directory Access Protocol)的缩写，LDAP 是从 X.500 目录访问协议的基础上发展过来的。与LDAP一样提供类似的目录服务软件还有 ApacheDS、Active Directory、Red Hat Directory Service。 特点 LDAP 的结构用树来表示，称为目录信息树（DIT）。正因为这样，就不能用 SQL 语句了 LDAP 可以很快地得到查询结果，不过在写方面，就慢得多 LDAP 提供了静态数据的快速查询方式 Client/Server 模型，Server 用于存储数据，Client 提供操作目录信息树的工具 这些工具可以将数据库的内容以文本格式（LDAP 数据交换格式，LDIF）呈现在您的面前 LDAP 是一种开放 Internet 标准，LDAP 协议是跨平台的 Interent 协议 LDAP 的体系结构由信息模型（信息表示方式）、命名模型（数据组织方式）、功能模型（数据操作访问方式）以及安全模型4种基本模型组成。 基本概念 Entry 条目（Entry），也叫记录项，是 LDAP 中最基本的颗粒，就像字典中的词条，或者是数据库中的记录。通常对 LDAP 的添加、删除、更改、检索都是以条目为基本对象的。 dn：每一个条目都有一个唯一的标识名（distinguished Name ，DN）。通过 DN 的层次型语法结构，可以方便地表示出条目在 LDAP 树中的位置，通常用于检索。从子树向根节点推。如示例中要获取 tom 这个节点，dn 应该为 cn=tom,ou=student,ou=people,dc=domain,dc=org。 rdn：一般指 dn 逗号最左边的部分，即叶子节点，如 cn=tom 。它与 RootDN 不同，RootDN 通常与 RootPW 同时出现，特指管理 LDAP 中信息的最高权限用户。 Base DN：LDAP 目录树的最顶部就是根。 Attribute 每个条目都拥有很多属性（Attribute），比如姓名、电话、密码等。每个属性都有名称和对应的属性值，属性值可以有多个。 属性不是随便定义的，需要符合一定的规则，而这个规则可以通过 schema 制定。比如，如果一个 entry 没有包含在 inetorgperson 这个 schema 中的 objectClass: inetOrgPerson，那么就不能为它指定 employeeNumber 属性，因为 employeeNumber 是在 inetOrgPerson 中定义的。 LDAP 为人员组织机构中常见的对象都设计了属性(比如commonName，surname)。下面有一些常用的别名： Name Alias objectClass Notes cn commonName person 姓名 dc domainComponent dcObject 域名 mail rfc822Mailbox inetOrgPerson 邮箱 o organizationName organization 组织（公司）名称 ou organizationalUnitName organizationalUnit 单位（部门）名称 sn surname person 姓 userPassword - organization 密码 uid userid account 用户名 objectClass 对象类（objectClass） 是属性的集合，LDAP 预想了很多人员组织机构中常见的对象，并将其封装成对象类。比如人员（person）含有姓（sn）、名（cn）、电话(telephoneNumber)、密码(userPassword)等属性，单位职工(organizationalPerson)是人员(person)的继承类，除了上述属性之外还含有职务（title）、邮政编码（postalCode）、通信地址(postalAddress)等属性。 通过对象类可以方便的定义条目类型。每个条目可以直接继承多个对象类，这样就继承了各种属性。如果2个对象类中有相同的属性，则条目继承后只会保留1个属性。对象类同时也规定了哪些属性是基本信息，必须含有(Must 或 Required，必要属性)：哪些属性是扩展信息，可以含有（May 或 Optional，可选属性）。 对象类有三种类型：结构类型（Structural）、抽象类型(Abstract)和辅助类型（Auxiliary）。结构类型是最基本的类型，它规定了对象实体的基本属性，每个条目属于且仅属于一个结构型对象类。抽象类型可以是结构类型或其他抽象类型父类，它将对象属性中共性的部分组织在一起，称为其他类的模板，条目不能直接集成抽象型对象类。辅助类型规定了对象实体的扩展属性。每个条目至少有一个结构性对象类。 schema 对象类（ObjectClass）、属性类型（AttributeType）、语法（Syntax）分别约定了条目、属性、值。所以这些构成了模式(Schema)——对象类的集合。条目数据在导入时通常需要接受模式检查，它确保了目录中所有的条目数据结构都是一致的。 编码 创建 LDAP 工具类 其中 getCtx() 方法用于与 LDAP 服务器建立连接，verifyPwd(String ldapPwd, String inputPwd) 用于判断用户输入的密码与 LDAP 中的密码是否匹配。LDAP 中的用户密码有多种加密方式，如 userPassword 是使用 SSHA 散列的，otherPassword 是使用 NT HASH 散列等。这边判断的是 userPassword，故将输入的明文密码转换成 SSHA 码后进行匹配。 import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Hashtable; import javax.naming.Context; import javax.naming.NamingException; import javax.naming.directory.DirContext; import javax.naming.directory.InitialDirContext; import com.novell.ldap.util.Base64; public class LdapUtil { private static final String ACCOUNT = &quot;account&quot;; private static final String PASSWORD = &quot;password&quot;; private static final String URL = &quot;ldap://127.0.0.1:389/&quot;; private static final String FACTORY = &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;; private static final String SEARCH_DN = &quot;,ou=Manager,dc=something,dc=com&quot;; private static DirContext ctx = null; public static DirContext getCtx() { if (ctx != null) { return ctx; } Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY, FACTORY); env.put(Context.PROVIDER_URL, URL); env.put(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;); env.put(Context.SECURITY_PRINCIPAL, &quot;uid=&quot; + ACCOUNT + SEARCH_DN); env.put(Context.SECURITY_CREDENTIALS, PASSWORD); try { ctx = new InitialDirContext(env); } catch (javax.naming.AuthenticationException e) { System.out.println(&quot;认证失败&quot;); } catch (Exception e) { System.out.println(&quot;认证出错：&quot;); e.printStackTrace(); } return ctx; } public static void closeCtx() { try { ctx.close(); } catch (NamingException e) { e.printStackTrace(); } } public static boolean verifyPwd(String ldapPwd, String inputPwd) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;); if (ldapPwd.startsWith(&quot;{SSHA}&quot;)) { ldapPwd = ldapPwd.substring(6); } else if (ldapPwd.startsWith(&quot;{SHA}&quot;)) { ldapPwd = ldapPwd.substring(5); } byte[] ldapPwdByte = Base64.decode(ldapPwd); byte[] shaCode, salt; if (ldapPwdByte.length &lt;= 20) { shaCode = ldapPwdByte; salt = new byte[0]; } else { shaCode = new byte[20]; salt = new byte[ldapPwdByte.length - 20]; System.arraycopy(ldapPwdByte, 0, shaCode, 0, 20); System.arraycopy(ldapPwdByte, 20, salt, 0, salt.length); } md.update(inputPwd.getBytes()); md.update(salt); byte[] inputPwdByte = md.digest(); return MessageDigest.isEqual(shaCode, inputPwdByte); } } 添加人员 public static boolean addUser(String uid, String pwd) { boolean success = false; DirContext ctx = null; try { ctx = LdapUtil.getCtx(); BasicAttributes attrsbu = new BasicAttributes(); BasicAttribute objclassSet = new BasicAttribute(&quot;objectclass&quot;); objclassSet.add(&quot;person&quot;); objclassSet.add(&quot;top&quot;); objclassSet.add(&quot;organizationalPerson&quot;); objclassSet.add(&quot;inetOrgPerson&quot;); attrsbu.put(objclassSet); attrsbu.put(&quot;sn&quot;, uid); attrsbu.put(&quot;uid&quot;, uid); attrsbu.put(&quot;userPassword&quot;, pwd); ctx.createSubcontext(&quot;cn=&quot; + uid + &quot;,ou=People&quot;, attrsbu); ctx.close(); return true; } catch (NamingException ex) { try { if (ctx != null) { ctx.close(); } } catch (NamingException namingException) { namingException.printStackTrace(); } } return false; } 用户验证 public boolean checkPassword(String uid, String password) { DirContext ctx = null; String searchDn = &quot;dc=something,dc=com&quot;; try { ctx = LdapUtil.getCtx(); SearchControls searchControls = new SearchControls(); searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE); String filter = &quot;(&amp;(objectClass=top)(uid=&quot; + uid + &quot;))&quot;; NamingEnumeration&lt;SearchResult&gt; answer = ctx.search(searchDn, filter.toString(), searchControls); while (answer.hasMoreElements()) { Object obj = answer.nextElement(); if (obj instanceof SearchResult) { SearchResult result = (SearchResult) obj; Attributes attrs = result.getAttributes(); Attribute userPassword = attrs.get(&quot;userPassword&quot;); String pwd = new String((byte[]) userPassword.get()); boolean check = LdapUtil.verifyPwd(pwd, password); return check; } } ctx.close(); } catch (NoSuchAlgorithmException e) { try { if (ctx != null) { ctx.close(); } } catch (NamingException namingException) { namingException.printStackTrace(); } } catch (NamingException ex) { try { if (ctx != null) { ctx.close(); LdapUtil.closeCtx(); } } catch (NamingException namingException) { namingException.printStackTrace(); } } return false; } 修改密码 public static boolean updatePwdLdap(String uid, String pwd) { boolean success = false; DirContext ctx = null; try { ctx = LdapUtil.getCtx(); ModificationItem[] modificationItem = new ModificationItem[1]; modificationItem[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE, new BasicAttribute(&quot;userPassword&quot;, pwd)); ctx.modifyAttributes(&quot;cn=&quot; + uid + &quot;,ou=People&quot;, modificationItem); ctx.close(); return true; } catch (NamingException ex) { try { if (ctx != null) { ctx.close(); } } catch (NamingException namingException) { namingException.printStackTrace(); } } return success; } 删除用户 public static boolean updatePwdLdap(String uid, String pwd) { boolean success = false; DirContext ctx = null; try { ctx = LdapUtil.getCtx(); ctx.destroySubcontext(&quot;cn=&quot; + uid); ctx.close(); return true; } catch (NamingException ex) { try { if (ctx != null) { ctx.close(); } } catch (NamingException namingException) { namingException.printStackTrace(); } } return success; } 参考 http://www.zytrax.com/books/ldap/ ","link":"https://ikerwin.com/post/Java-LDAP/"}]}